package com.gqx.e_aop_anno;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component 	//加入IOC容器
@Aspect		//指定当前类为切面类
public class Aop {
	//指定切入点表达式，说明要拦截哪些方法（为哪些方法生成代理对象）
	@Pointcut("execution(* com.gqx.e_aop_anno.*.*(..))")
	public void pointCut_(){
		
	}
	
	//前置通知：在执行目标方法之前执行
	@Before("pointCut_()")
	public void begin(){
		System.out.println("开始事物/异常");
	}
	
	//后置通知：执行目标方法之后执行  （无论是否出现异常都会执行）
	@After("pointCut_()")
	public void commit(){
		System.out.println("提交事物！");
	}
	
	/*//返回后通知：调用目标方法结束后执行
	@AfterReturning("pointCut_()")
	public void afterReturning(){
		System.out.println("AfterReturning....");
	}*/
	
	/*//异常通知：当目标方法出现异常的时候执行
	@AfterThrowing("pointCut_()")
	public void afterThrowing(){
		System.out.println("afterThrowing....");
	}*/
	
	//环绕通知：环绕目标之前或者之后执行
	@Around("pointCut_()")
	public void around(ProceedingJoinPoint pjp) throws Throwable{
		System.out.println("环绕前：Around.....");
		Object returnValue=pjp.proceed();  //执行目标方法
		System.out.println("环绕后：Around.....");
	}
}
